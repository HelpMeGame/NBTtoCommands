#################################
#    Developed By HelpMeGame    #
#       Using Python-NBT        #
#################################
import os
import json
import shutil
from zipfile import ZipFile
import python_nbt.nbt as nbt


# Read the NBT file, and convert it to JSON
def Read(type: str, file_name):
    print("Working....")
    # For Multiple files, create a list of JSON data elements to parse through later
    datas = []
    if type == "multiple":
        file_names = file_name.split(" ")
        file_name = "Grouped"
        for x in file_names:
            data = nbt.read_from_nbt_file(f"{x}.nbt")
            datas.append(nbt.NBTTagBase.json_obj(data, full_json=True))
    else:
        # For Single files, do the same as Multiple, but only fill it with one element
        data = nbt.read_from_nbt_file(f"{file_name}.nbt")
        datas.append(nbt.NBTTagBase.json_obj(data, full_json=True))
    Parse(file_name, datas)


# Read the JSON data and convert into minecraft setblock commands
def Parse(file_name: str, data):
    print("Parsing...")
    # For each JSON file that was passed (in this case, x), gather and create a command list
    for x in range(0, len(data)):
        palette = []
        # Collect all the used blocks, and assign them to a list
        for item in data[x]['value']['palette']['value']:
            if item['Name']['value'] == "water" or item['Name']['value'] == "ice":
                palette.append("light_blue_wool")
            else:
                palette.append(item['Name']['value'])

        # The actual blocks and their types/locations
        blocks = data[x]['value']['blocks']['value']

        command_list = ""

        # Generate the setblock command, and add it to the command_list string
        for block in blocks:
            positions = block['pos']['value']
            block_type = block['state']['value']
            command_list += f"setblock ~{positions[0]} ~{positions[1] + 1} ~{positions[2]} {palette[block_type]}\n"

        # Create the necessary files for Minecraft to recognize the commands as a datapack Function
        path = f"./data/{file_name}ns/functions".lower()
        if not os.path.exists(path):
            os.makedirs(path)

        with open(f"{path}/{x + 1}.mcfunction", "w") as f:
            f.write(command_list)
            f.close()

    # Create "Pack.mcmeta", which contains basic information about the datapack. This is needed for MC to recognize it
    pack_data = {
        "pack": {
            "pack_format": 7,
            "description": f"Autogenerated Function Datapack for Map Art ({file_name})"
        }
    }
    with open(f"./pack.mcmeta", "w") as f:
        json.dump(pack_data, f, indent=3)
        f.close()

    # Zip all the files into a nice tidy .zip file
    to_zip_path = f"./data/"
    paths = get_all_paths(to_zip_path)
    with ZipFile(f'{file_name}_pack.zip', "w") as zipfl:
        for file in paths:
            zipfl.write(file)
        zipfl.write(f"./pack.mcmeta")

    # Remove the extra generated folders and files
    shutil.rmtree("./data")
    os.remove("./pack.mcmeta")

    print("Done!\n\n")


# Collect all the paths of a directory. Used for gathering all the functions after generation
def get_all_paths(path):
    file_paths = []
    for root, folders, files in os.walk(path):
        for filename in files:
            file_path = os.path.join(root, filename)
            file_paths.append(file_path)
    return file_paths


# Main function definition, just the prompt that gathers data from the User.
def main():
    while True:
        file_type = input("Type (Multiple, Single):\n").lower()
        if file_type != "multiple" and file_type != "single":
            print("Please use either Multiple, or Single.\n\n")
            continue
        file_names = input("File Name(s), separated by a space (\" \"):\n")
        for file in file_names.split(" "):
            found = os.path.exists(f"./{file}.nbt")
            if not found:
                print(f"{file}.nbt could not be found.\n\n")
                break
        if found:
            Read(file_type, file_names)


# Start the program
main()
